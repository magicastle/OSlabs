# ucore lab3 实验报告

## 实验目的

- 了解虚拟内存的 Page Fault 异常处理实现
- 了解页替换算法在操作系统中的实现

## 实验内容

### 练习1：给未被映射的地址映射上物理页

完成 do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制结构所指定的页表，而不是内核的页表。

- 设计实现过程

首先了解PageFault异常处理过程，有以下三种三种情况会触发缺页异常：

    1. 目标页帧不存在（页表项全为 0，即该线性地址与物理地址尚未建立映射或者已经撤销)；
    2. 相应的物理页帧不在内存中（页表项非空，但 Present 标志位=0，比如在 swap 分区或磁盘文件上)；
    3. 不满足访问权限(此时页表项 P 标志=1，但低权限的程序试图访问高权限的地址空间，或者有程序试图写只读页面).

产生页面 page fault 异常后，与其他异常处理一样，CPU进行一些常规操作，然后调用中断服务历程，调用流程如下：
    
    trap--> trap_dispatch-->pgfault_handler-->do_pgfault

do_pgfault()函数中，首先查询mm_struct中的合法的虚拟地址链表，用于确定当前出现page fault的线性地址是否合法，如果合法则继续执行调出物理页，否则直接返回；接下来使用error code，以及查找到的该线性地址的内存页是否允许读写来判断是否出现了读/写不允许读/写的页这种情况，如果出现了上述情况，则应该直接返回，否则继续执行page fault的处理流程；接下来根据合法虚拟地址的标志，来生成对应产生的物理页的权限；    

练习1中需要处理的情况即为第一种，页表项全为零,还没有映射的物理页，需要调用pgdir_alloc_page来为其分配一个物理页，在pgdir_alloc_page函数中，分配并映射页面之后调用了swap_map_swappable函数用来将该页设置为可交换页，具体需要实现将该页插入到可交换页链表中，本次实验中在swap_init函数中使用了基于FIFO替换策略的swap_manager_fifo，因此真正调用的是swap_fifo.c中实现的_fifo_map_swappable，在该函数中，将新加入的页添加到可交换页链表的最后。

- 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对 ucore 实现页替换算法的潜在用处。

页目录项（PDE）组成部分：

    前20位表示4K对齐的该PDE对应的页表起始位置（物理地址，该物理地址的高20位即PDE中的高20位，低12位为0）；
    第9-11位未被CPU使用，可保留给OS使用；
    接下来的第8位可忽略；
    第7位用于设置Page大小，0表示4KB；
    第6位恒为0；
    第5位用于表示该页是否被使用过；
    第4位设置为1则表示不对该页进行缓存；
    第3位设置是否使用write through缓存写策略；
    第2位表示该页的访问需要的特权级；
    第1位表示是否允许读写；
    第0位为该PDE的存在位；

页表项（PTE）组成部分：

    高20位与PDE相似的，用于表示该PTE指向的物理页的物理地址；
    9-11位保留给OS使用；
    7-8位恒为0；
    第6位表示该页是否为dirty；
    第5位表示是否被访问；
    3-4位恒为0；
    第2位表示该页的访问需要的特权级；
    第1位表示是否允许读写；
    第0位为该PTE的存在位；

可以发现PDE和PTE的第9-11位均为给操作系统的保留位，可以使用他们为一些页面替换算法提供支持。第0位存在位可以可以表示内存中的存在状态，若存在位为0，那么可以用其他位来记录一些信息，如ucore中记录的该物理页在交换分区中的位置。PTE中的dirty位，可以用来判断是否需要在swap out的时候写回外存。

- 如果 ucore 的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

一般情况下，操作系统所在的内核空间的页面是不能被换出的，如果在操作系统执行过程中，发生了缺页现象，则最终硬件需要完成的处理与正常出现页访问异常的处理相一致，操作系统不得不等很长时间（硬盘的访问速度比内存的访问速度慢 2~3 个数量级），这将导致整个系统运行低效。处理缺页过程所用到的内核代码或者数据如果被换出，整个内核都面临崩溃的危险。

### 练习2：补充完成基于 FIFO 的页面替换算法

完成 vmm.c 中的 do_pgfault 函数，并且在实现 FIFO 算法的 swap_fifo.c 中完成 map_swappable 和 swap_out_victim 函数。通过对 swap 的测试。

- 设计实现过程

该练习中需要处理第二种情况，存在位为零PTE不全为零，即相应的物理页帧不在内存中，需要调用swap_in函数将该页换入内存。在swap_in函数中，首先调用alloc_page，然后将pte中记录的swap分区中的页读入新分配的物理页，在阿alloc_page中如果没有freepage会调用swap_out，将选取内存中的页换出，在本练习中，实现的FIFO替换算法中，即将驻留时间最长的位于链表头的页取出换到交换区中即可。

换入内存中后，还需调用page_insert建立虚拟页到物理页的映射，再将新换入的页设为可交换的页。

- 在现有框架基础上可以支持Extended clock算法，具体设计方案如下所示：

将可以被换出的物理页组成一个环形链表，定义一个指针current_clock,发生缺页时从current_clock处开始遍历环形链表，根据链表表项list_entry找到Page结构，再访问Page结构的pra_vaddr变量，最后通过get_pte函数获取PTE表项，寻找访问位和修改位均为零的页进行置换。如果访问位为0但修改位为1，则可以写入到外存，如果访问位为1那么在新的周期中将其重置为0。那么相应的，在访问时需要更新访问位和修改位，以保证Extended clock算法的正确执行。

- 需要被换出的页的特征是什么？

    该物理页在当前指针上一次扫过之前没有被访问过；
    该物理页的内容与其在外存中保存的数据是一致的, 即没有被修改过;

- 在 ucore 中如何判断具有这样特征的页？

    PTE的Access位和Dirty位可用来判断访问情况和修改情况；

- 何时进行换入和换出操作？

    page_fault发生是进行换入操作；
    当分配页面没有空闲页面时进行换出操作；

### 扩展练习 Challenge 1：实现识别 dirty bit 的 extended clock 页替换算法

按照练习二思考题中的思路，在swap_clock.c中实现extended clock页面替换算法，并设计了相关的检查。将swap_init中的 sm = &swap_manager_fifo; 改为 sm = &swap_manager_clock;

## 实验小结

- 参考答案分析对比

    与答案相比少了很多assert检查，另外根据注释的提示，FIFO替换算法维护的链表，我将最新加入的页放在队尾，而答案放在队首，但是只要取的时候从另一端取就没有什么差别了。

- 实验中重要知识点与其对应的OS原理

    虚拟内存管理的基本概念与原理；
    page fault异常的处理流程；
    页替换算法中较为简单的FIFO算法和改进时钟算法；

- 未出现的OS知识点

    其他的局部页替换算法；
    全局置换算法；

