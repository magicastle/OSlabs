# ucore lab4 实验报告

## 实验目的

- 了解内核线程创建/执行的管理过程
- 了解内核线程的切换和基本调度过程

## 实验内容

### 练习 1：分配并初始化一个进程控制块

alloc_proc 函数（位于 kern/process/proc.c 中）负责分配并返回一个新的 struct proc_struct 结构，用于存储新建立的内核线程的管理信息。ucore 需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。

- 设计实现过程

理解 struct proc_struct 结构的各个成员变量的含义，并赋给其合适的初值:

    state：进程所处的状态，由于分配进程控制块时，进程还处于创建阶段，因此设置其状态的PROC_UNINIT，表示尚未完成初始化；
    pid：进程的标识，需要后续根据实际情况再进行分配，因此初始化为-1，这也表示了该进程在此时还是一个无效进程；
    runs：程序运行的时间，初始化为0；
    kstack：内核栈地址，分配阶段未知，初始化为0；
    need_resched：标记是否需要调度其他进程，初始化为0，表示不需调度其他进程；
    parent：记录父进程，分配时未知，初始化位NULL；
    mm：进程的内存空间，还未分配所以初始化为NULL；
    context：记录进程上下文，是中断时要用到的，用memset全部初始化为0；
    tf：中断帧，中断时用到，初始化为NULL；
    cr3：储存页目录表的基址，设置为前面已经创建好的页目录表boot_pgdir的物理地址；
    flags：标志初始化为0，后续根据需要设置；
    name：进程名字，分配时未知，初始化为0；

- 请说明 proc_struct 中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？

struct context 结构中存储着除了eax之外的所有通用寄存器以及eip的值，是进程运行的上下文信息；struct trapframe 保存了context的内容，以及段寄存器、中断号、错误码和状态寄存器等信息的中断帧。

在本实验中，创建新的线程的时候，根据新线程的信息创建一个中断帧，另外在 copy_thread 中将 context中的eip设置为fort_ret esp设置为tf的地址，然后当调度器调度这个已被设为PROC_RUNNABLE 的线程时，在proc_run 函数中进行上下文切换，根据eip进入forkret函数，最终调用了__trapret进行中断返回，这样便可以根据tf中构造的中断返回地址，切换到新的线程了。所以整体来看，就是利用context进行调度切换，再利用trapframe构造的中断返回现场，真正切换到新线程。

### 练习 2：为新创建的内核线程分配资源

创建一个内核线程需要分配和设置好很多资源。kernel_thread 函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel 函数会调用 alloc_proc 函数来分配并初始化一个进程控制块，但 alloc_proc 只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore 一般通过 do_fork 实际创建新的内核线程。do_fork 的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。你需要完成在 kern/process/proc.c 中的 do_fork 函数中的处理过程。

- 设计实现过程

实现的代码位于proc.c的do_fork函数中，主要是为内核线程创建新的线程控制块，并且对控制块中的每个成员变量进行正确的设置，并将该线程加入到队列中，参考注释完成实现。需要注意如果在过程中失败，需要将已申请的资源释放。

- 请说明 ucore 是否做到给每个新 fork 的线程一个唯一的 id？请说明你的分析和理由。

分析get_pid函数的内容，该函数维护了两个局部静态变量 next_safe 和 last_pid，每次分配大于last_pid 小于next_safe 的pid值即可，可以保证给每个新 fork 的线程一个唯一的 id 。

### 练习 3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的

- 对 proc_run 函数的分析
  
首先这个函数是在schedule函数中被调用的，基本语义就是将CPU的控制权交给指定的线程。进一步查看proc_run的代码，可以看到该函数中首先进行了TSS以及cr3寄存器的设置，然后调用swtich_to函数来切换上下文，由于已经设置好的eip的值，进入forkret函数，之后会进一步以调用中断的方式，真正进入新线程。

- 在本实验的执行过程中，创建且运行了几个内核线程？
  
一共创建了两个内核线程，分别为 idleproc 和 initproc 。

- 语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);在这里有何作用?请说明理由

该语句是关闭中断，使得在这个语句块内的内容不会被中断打断，是一个原子操作。具体在这里可以避免在进程切换的过程中被打断出现错误，比如设置了current 为新线程，但实际还未真正转移控制权，此时若被打断，current就不是当前正在运行的线程了，可能会出现一些无知的错误。

## 实验小结

- 参考答案分析对比

练习1的内容仅仅是初始化进程控制块，比较简单实现与参考答案基本一致；练习2中，参考答案在设置fork的线程的关键信息以及将其加入proc列表的时候关闭了中断，防止被中断打断操作从而导致存储线程的信息的不一致，而我的实现并未考虑到这一点。   

- 实验中重要知识点与其对应的OS原理

    进程控制块的组成；
    多个进程（内核线程）间的切换的实现方法；

- 未出现的OS知识点

在本次实验中未涉及的知识点有：

    进程多个状态间的转换；
    用户线程；

